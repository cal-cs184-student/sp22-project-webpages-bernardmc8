<html>
	<head>
	</head>
	<body>

	<p><big> Part 1: </big></p>
	<p>1.1: Some screenshots of the wireframe from scene/pinned2.json: </p>
	<p>Without any shearing constraints:</p>
	<img src="images/task1_1.png">
	<p>With only shearing constraints:</p>
	<img src="images/task1_2.png">
	<p>With all constraints:</p>
	<img src="images/task1_3.png">

	<p><big> Part 2: </big></p>
	<p>2.1: Playing around with some values of ks, density, damping</p>
	<p>First, here is pinned2.json with default parameters (density: 15 g/cm^2, ks: 5,000 N/m, damping: 0.2%)</p>
	<img src="images/task2_1.png">
	<p>2.1 (cont.): Playing with values of ks </p>
	<p>In general, the value of ks describes the stiffness of the spring. When we increase the value of ks, we increase the stiffness of the springs: that is, it requires more force in order to change the length of the spring. </p>
	<p>When looking at pinned2 mid-fall with ks 5,000 N/m, we see a crease form in the middle of the sheet as a result of gravity pulling the middle down but the corners being pinned (the image below is the same as the default one above). </p>
	<img src="images/task2_1.png">
	<p>When we increase ks to 50,000 N/m, we see that at a similar position of the sheet mid-fall, there is no longer a crease in the middle of the sheet (note that there is a crease in the beginning of the fall but the crease disappears faster). That is because, the stiffer the spring, the more resistant to force the springs will be. Intuitively, this visual difference makes sense. You can imagine a sheet with infinite ks as acting as one distinct object, like a slab of wood instead of a sheet. In this case, the slab of wood would just hinge on the two points and essentially rotate flatly without changing shape. So basically, as we increase ks, the sheet acts more and more like a solid slab of wood in that the shape is more resistant to change. </p>
	<img src="images/task2_3.png">
	<p>When we decrease ks to 5 N/m, the opposite happens. The springs are less rigid so the sheet as a whole changes shape more. We can see this in the scene as the crease in the middle of the sheet at a given position as it is falling is deeper than with the default ks. </p>
	<img src="images/task2_6.png">
	<p>Also, there is much less of a "shelf" where the sheet folds over horizontally once the sheet has fallen</p>
	<img src="images/task2_4.png">
	<p>2.1 (cont.): Playing with values of density </p>
	<p>In general, the value of density visually does the opposite of what the value of ks does.</p>
	<p>When we decrease the density to 1 g/cm^2, we see that the crease in the middle of the sheet disappears very quickly into the fall </p>
	<img src="images/task2_7.png">
	<p>Conversely, when we increase the density to 150 g/cm^2, the crease is deeper at a similar point of the fall</p>
	<img src="images/task2_8.png">
	<p>2.1 (cont.): Playing with values of damping </p>
	<p>Generally, the damping parameter controls how much the springs can bounce back so a higher damping percentage means the springs are really free to bounce back and forth while a lower damping percentage means the springs reach equilibrium very quickly </p>
	<p>When we increase the damping percentage to 100%, the sheet just swing falls and then instead of coming to rest fairly quickly, it way overshoots just laying vertical and swings back and forth like a swing on a playground. </p>
	<img src="images/task2_9.png">
	<p>When we decrease the damping percentage to 0%, it falls extremely slowly and then comes to rest without having to really move too far and then swing back. Visually, it appears to reach equilibrium without even having to overshoot and then correct back by swinging the opposite direction.</p>
	<img src="images/task2_0.png">
	<p>2.2: pinned4 in final resting state with default parameters: </p>
	<img src="images/task2_final.png">

	<p><big> Part 3: </big></p>
	<p>3.1: sphere.json in final resting state with various ks values </p>
	<p>ks=500</p>
	<img src="images/task3_500.png">
	<p>ks=5000</p>
	<img src="images/task3_5000.png">
	<p>ks=50000</p>
	<img src="images/task3_50000.png">
	<p>As we decrease ks, the stiffness of the spring decreases, so the lower the ks, the more cloth visually drapes over the sphere. As we increase ks, it requires more force to pull the springs the same distance, so since the magnitude of gravity pulling down doesn't change, we can see that the higher ks valued scenes have a cloth that is more rigid. Again, one way to think about this is the higher the ks, the closer the cloth would be to just a wooden slab, and a wooden slab would just lay horizontally flat on top of the sphere. In conclusion, basically decreasing ks makes the cloth drape over the ball more and increasing ks makes the cloth more rigid. </p>
	<p>3.2: cloth.json in final resting state with default values </p>
	<img src="images/task3_plane.png">

	<p><big> Part 4: </big></p>
	<p>4.1: selfCollide.json cloth falling with default parameters</p>
	<p>Early self collisions</p>
	<img src="images/task4_1.png">
	<p>Late self collisions</p>
	<img src="images/task4_2.png">
	<p>Cloth basically at rest</p>
	<img src="images/task4_3.png">
	<p>4.2: selfCollide.json cloth falling with various parameters</p>
	<p>Generally, ks affects the self-collision of the cloth in that the higher the ks, the higher the rigidity of the springs, so the cloth is more resistant to change. That is why, in the higher ks scene, the cloth only has a couple of large folds whereas the lower ks scene has many folds. Again, one way to think about ks is that if ks was infinitely high, the cloth would behave like a slab, and a slab falling on itself would have no folds, so generally, the higher the ks the less folds would be in the resting cloth and the lower the ks the more folds would be in the resting cloth. However, I will say that number of folds and ks is not exactly a direct correlation, due to how the cloth falls this relationship might be slightly different but generally, comparing very high ks and very low ks this will be true. </p>
	<p>High KS:</p>
	<img src="images/task4_highks.png">
	<p>Low KS:</p>
	<img src="images/task4_lowks.png">
	<p>Generally, density acts oppositely to ks. The higher the density the more folds the resting cloth will have and the lower the density the less folds the resting cloth will have. We can see this in the images, especially in the low density image, which has a very straight piece of cloth at the end.</p>
	<p>High density:</p>
	<img src="images/task4_highdens.png">
	<p>Low density:</p>
	<img src="images/task4_lowdens.png">

	<p><big> Part 5: </big></p>
	<p>5.1: A shader program is a rather simple isolated input/output program that defines some sort of transformation on vertices or fragments in order to change their color or position vectors based on some purpose the shader is trying to fulfill. It's main use is that because it can run parallel on the GPU, it can execute sections of the graphics pipeline much faster than if we did everything on the CPU like we did in projects 3-1 and 3-2. Vertex shaders deal primarily with geometric properties, and they can for example change the position and normal vectors of the vertices. Fragment shaders deal more with color and light. Vertex and fragment shaders work together as vertex shaders will write the final position of the vector after some transformation as well as some variables that will be used by the fragment shader and then the fragment shader will process fragments after rasterization by using the positional features of the fragments, which were calculated and set by the vertex shader, to then compute the color of the pixel based on the geometry and how the light would shine on it.  </p>
	<p>5.2: The Blinn-Phong Reflection Model aims to simulate realistically looking graphics by combining three aspects of lighting that can make a pixel look realistic. The first is just the ambient lighting, which is general lighting across the whole scene. The second is diffuse lighting, which we implemented in the Task 1 of this part, and it is for scattered light that falls on the object based on what parts of the object are facing the light. Diffuse lighting is what indirectly defines the shadows on an object because it lights up the object based on where the light would hit it, like in real life. The third and final part is specular lighting, which renders the "glare" that can often be seen on reflective or semi-reflective surfaces. Parts of an object that are facing the light often reflect the light source directly, and so the object will appear glossy or shiny in those areas, which specular lighting aims to reproduce. Adding these three elements together gives you the Blinn-Phong shading model, which is a pretty good estimate of how things look in real life. In fact, it's the default shading model for OpenGL and Direct3D (source: wikipedia Blinn-Phong reflection model page) </p>
	<p>Sphere.json with only ambient lighting component</p>
	<img src="images/task5_1.png">
	<p>Sphere.json with only diffuse lighting component</p>
	<img src="images/task5_2.png">
	<p>Sphere.json with only specular lighting component</p>
	<img src="images/task5_3.png">
	<p>Sphere.json with all components (entire Blinn-Phong model)</p>
	<img src="images/task5_4.png">
	<p>5.3: Texture Mapping of Oski (textures/oski.png) onto Sphere.json </p>
	<img src="images/task5_5.png">

	<p>5.4: couldn't figure it out :( </p>

	<p>5.5: Mirror shader on Sphere.json</p>
	<img src="images/task5_mirror.png">
	<img src="images/task5_mirror2.png">

	</body>
</html>